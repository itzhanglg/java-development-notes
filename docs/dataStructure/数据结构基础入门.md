数据结构和算法可视化网址推荐：[Algorithms](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html) 、[visualgo](https://visualgo.net/zh) 、[algorithm-visualizer](https://algorithm-visualizer.org/) 。

数据结构知识点如下图：

![image-20210102202028565](https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102202028565.png)

如上图，常见的数据结构有线性表、散列表、树和图等。常见数据结构时间复杂度如下：

![image-20210101213330817](https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101213330817.png)

## 一.数据结构基本概念

数据结构(data structure)是计算机存储、组织数据的方式。**数据结构是指相互之间存在一种或多种特定关系的数据元素的集合**。数据结构包括三方面的内容：存储结构、逻辑结构和数据的运算。（在内存中存储数据）

**存储结构**是指数据结构在计算机中的表示（又称映像)。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。

- 顺序存储：存储的物理位置相邻（如数组）； 
- 链式存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素（如链表）；
- 索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解；
- 散列存储：通过关键字直接计算出元素的物理地址。

**逻辑结构**是指数据元素之间的逻辑关系。数据的逻辑结构分为线性结构和非线性结构。

- 线性结构：结构中的数据元素之间只存在一对一的关系。
    - 非受限线性表：数组、链表；
    - 受限线性表：栈、队列、顺序表。                                                                    
- 非线性结构：集合结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。
    - 树形结构：结构中的数据元素之间存在一对多的关系；
    - 图状结构或网状结构：结构中的数据元素之间存在多对多的关系。

## 二.数据结构之线性表

线性表（Linear List）就是数据排成像一条线一样的结构，数据只有前后两个方向。**线性表**是具有**相同数据类型**的n（n≥0）个数据元素的**有限序列**。线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。

### 1.数组

#### 1.1 概念

数组（Array）是**有限个相同类型**的变量所组成的**有序**集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。数组下标从零开始。

存储原理：用一组**地址连续的存储单元**依次存储线性表中的**相同类型**数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配。

![image-20210101204935217](https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101204935217.png)

随机元素寻址公式：`a[i]_address=a[0]_address+i*4`，该公式解释了三个方面 连续性分配、相同的类型、下标从0开始。

数组优缺点：

- 随机访问，通过首地址和元素序号可以在O(1)的时间内找到指定的元素；
- 每个结点只存储数据元素，无需维护逻辑关系；
- 插入和删除操作需要移动大量元素，影响效率。如超出范围，需要重新申请内存进行存储，原空间就浪费了
- 申请的空间必须是连续的，即使有空间也可能因为没有足够的连续空间而创建失败。

数组是基础的数据结构，**应用**太广泛了，ArrayList、Redis、消息队列等等。

#### 1.2 常见操作

**读取和更新操作时间复杂度都为O(1)，插入和删除操作时间复杂度都为O(n)**。

**读取元素**：根据下标读取元素的方式叫作随机读取。

```java
int n=nums[2]
```

**更新元素**：注意不要数组越界。

```java
nums[3]= 10;
```

**插入元素**有三种情况：

- 尾部插入：直接把插入的元素放在数组尾部的空闲位置即可，等同于更新元素的操作。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101205432514.png" alt="image-20210101205432514" style="zoom: 50%;" />

- 中间插入：由于数组的每一个元素都有其固定下标，所以首先把插入位置及后面的元素向后移动，腾出地方，再把要插入的元素放到对应的数组位置上。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101205550512.png" alt="image-20210101205550512" style="zoom: 53%;" />

- 超范围插入：插入位置是越界的，这时就要对原数组进行扩容。可以创建一个新数组，长度是旧数组的2倍，再把旧数组中的元素统统复制过去，这样就实现了数组的扩容。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101210129088.png" alt="image-20210101210129088" style="zoom: 55%;" />

**删除元素**：数组的删除操作和插入操作的过程相反，如果删除的元素位于数组中间，其后的元素都需要向前挪动1位。若数组元素没有顺序要求时，可以将最后一个元素复制到删除的位置，再删除掉最后一个元素，这样时间复杂度降低为O(1)，这种方式只作参考。

#### 1.3 代码实现

```java
/**
 * @author zlg
 * @create 数组增删改查
 */
public class ArrayDemo {
    // 初始化数据
    int[] nums = new int[8];
    public ArrayDemo() {
        nums[0] = 3;
        nums[1] = 1;
        nums[2] = 2;
        nums[3] = 5;
        nums[4] = 4;
        nums[5] = 9;
    }
    
    // 1.查询
    public int get(int i) {
        return nums[i];
    }
    // 2.修改
    public void update(int i, int n) {
        nums[i] = n;
    }
    
    // 3.尾部插入
    public void insertTail(int n) {
        nums[6] = n;
    }
    // 4.中间插入：p为插入位置，n为插入值
    public void insertMiddle(int p, int n) {
        // 从右往左遍历，依次将元素后移一位
        for (int i = nums.length - 1; i >= p - 1; i--) {
            //能取得值
            if (nums[i] != 0) {
                nums[i + 1] = nums[i];
            }
        }
        // 插入值
        nums[p - 1] = n;
    }
    // 5.越界插入
    public void insertOutOfBounds(int p, int n) {
        //数组扩容
        resize();
        nums[p - 1] = n;
    }
    // 旧数组复制到新数组
    public void resize() {
        int[] numsNew = new int[nums.length * 2];
        System.arraycopy(nums, 0, numsNew, 0, nums.length);
        nums = numsNew;
    }
    
    // 6.删除元素，将元素依次前移一位
    public void deleteMiddle(int p) {
        for (int i = p; i < nums.length; i++) {
            nums[i - 1] = nums[i];
        }
    }
    
    // 7.遍历元素
    public void display() {
        for (int n : nums) {
            System.out.println(n);
        }
    }
    public void display2() {
        for (int i = nums.length - 1; i >= 0; i--) {
            System.out.println(nums[i]);
        }
    }
    
    // 测试
    public static void main(String[] args) {
        ArrayDemo demo1 = new ArrayDemo();
        demo1.deleteMiddle(3);
        demo1.display();
    }
}
```

### 2.链表

#### 2.1 概念

链表（linked list）是一种在物理上**非连续、非顺序**的数据结构，由**若干节点**（node）所组成。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的**数据域**，另一个是存储下一个结点地址的**指针域**。

- 头节点：带头结点链表中的第一个结点，前置节点为空；结点内通常不存储信息，用来记录链表的基地址，可以遍历得到整条链表。
- 头指针：不管带不带头结点，头指针始终指向链表的第一个结点；
- 尾节点：链表中最后一个节点，它指向的next为空。

**存储原理**：数组在内存中的存储方式是顺序存储（连续存储），链表在内存中的存储方式则是**随机存储**（链式存储）。链表的每一个节点分布在内存的不同位置，依靠next指针关联起来。这样可以灵活有效地利用零散的碎片空间。

链表**优缺点**：插入、删除、更新效率高；省空间。查询效率较低，不能随机访问。

- 数组的优势在于能够快速定位元素，对于**读操作多、写操作少**的场景来说，用数组更合适一些；
- 链表的优势在于能够灵活地进行**插入和删除**操作，如果需要在尾部频繁插入、删除元素，用链表更合适
    一些。

**链表的应用**也非常广泛，比如树、图、Redis的列表、LRU算法实现、消息队列等。常见的链表包括：单向链表、双向链表、循环链表和静态链表。

**单向链表**：每一个节点包含两部分：一部分存放数据的变量data，另一部分是指向下一个节点的指针next。

![image-20210101214432701](https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101214432701.png)

```java
Node{
    int data;
    Node next;
}
```

特点：不支持随机访问，需要遍历去访问节点；插入和删除只需要移动指针，以及修改操作时间复杂度都为O(1)(不考虑操作之前查找元素的过程)，查询的时间复杂度为O(n)；每个节点需要额外的空间存储指针，需要的内存比数组大。

**双向链表**：双向链表的每一个节点除了拥有data和next指针，还拥有指向前置节点的prev指针。

![image-20210101214736117](https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101214736117.png)

```java
Node{
    int data;
    Node next;
    Node prev;
}
```

**循环链表**：链表的尾节点指向头节点形成一个环，称为循环链表。循环链表又分为循环单链表和循环双链表。

- 循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。

![image-20210101215240380](https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101215240380.png)

- 循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环，尾节点next指向头节点，头节点prev指向尾节点，形成两个环。

![image-20210101215136005](https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101215136005.png)

**静态链表**：静态链表是用数组(Node[])来描述线性表的链式存储结构。数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101215517606.png" alt="image-20210101215517606" style="zoom:60%;" />

```java
public static class Node<T>{
    private T value;  // 数据域
    private int cur;  // 相当于next指针
}
```

#### 2.2 常见操作

**查找节点时间复杂度为O(n)，插入/更新/删除节点时间复杂度为O(1)**。

**查找节点**：在查找元素时，链表只能从头节点开始向后一个一个节点逐一查找。

**更新节点**：找到要更新的节点，然后把旧数据替换成新数据。

**插入节点**：

- 尾部插入：把最后一个节点的next指针指向新插入的节点即可。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101221453094.png" alt="image-20210101221453094" style="zoom:60%;" />

- 头部插入：把新节点的next指针指向原先的头节点；把新节点变为链表的头节点。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101221622099.png" alt="image-20210101221622099" style="zoom:60%;" />

- 中间插入：新节点的next指针，指向插入位置的节点；插入位置前置节点的next指针，指向新节点。只要内存空间允许，能够插入链表的元素是无限的，不需要像数组那样考虑扩容的问题。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101221832454.png" alt="image-20210101221832454" style="zoom:60%;" />

**删除节点**：

- 尾部删除：把倒数第2个节点的next指针指向空即可。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101222036243.png" alt="image-20210101222036243" style="zoom:60%;" />

- 头部删除：把链表的头节点设为原先头节点的next指针即可。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101222145727.png" alt="image-20210101222145727" style="zoom:60%;" />

- 中间删除：把要删除节点的前置节点的next指针，指向要删除元素的下一个节点即可。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101222207574.png" alt="image-20210101222207574" style="zoom:60%;" />

**常用操作**：

- 添加数据到链表中：遍历找到尾节点，插入即可(只要while(temp.next != null)，退出循环就会找到尾节点)。
- 遍历链表：从首节点(有效节点)开始，只要不为null，就输出。
- 给定位置插入节点到链表中：首先判断该位置是否有效(在链表长度的范围内)；找到想要插入位置的上一个节点，将原本由上一个节点的指向交由插入的节点来指向，上一个节点指针域指向想要插入的节点。
- 获取链表的长度：每访问一次节点，变量++操作即可。
- 删除给定位置的节点：首先判断该位置是否有效(在链表长度的范围内)；找到想要插入位置的上一个节点，将原本由上一个节点的指向后面一个节点。
- 对链表进行排序：使用冒泡算法对其进行排序。
- 找到链表中倒数第k个节点：设置两个指针p1、p2，让p2比p1快k个节点，同时向后遍历，当p2为空，则p1为倒数第k个节点；或者(-k+1+链表总数) % 链表总数。
- 查询链表的中间节点：一个每次走1步，一个每次走两步，走两步的遍历完，然后走一步的指针，那就是中间节点。
- 递归从尾到头输出单链表：只要下面还有数据，那就往下找，递归是从最后往前翻。
- 反转链表：有递归和非递归两种方式。

#### 2.3 代码实现

```java
/**
 * @author zlg
 * @create 单链表操作
 */
public class SingleLinkedList {
    
    //初始化头节点
    private Node head = new Node(0, "");
    
    // 添加节点：从头插入
    public void addNode(Node node) {
        //从头插入
        Node tmp = head;
        while (true) {
            //到尾节点
            if (tmp.next == null) {
                break;
            }
            //后移一个节点
            tmp = tmp.next;
        }
        tmp.next = node;
    }
    
    // 添加节点：按Node的Id排序添加
    public void addByIdOrder(Node node) {
        //从头插入
        Node tmp = head;
        while (true) {
            //到尾节点
            if (tmp.next == null) {
                break;
            }
            //节点存在
            if (tmp.next.id == node.id) {
                break;
            }
            if (tmp.next.id > node.id) {
                break;
            }
            tmp = tmp.next;
        }
        //交换位置
        node.next = tmp.next;
        tmp.next = node;
    }
    
    // 遍历链表
    public void showList() {
        //空链表
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        Node temp = head.next;
        while (true) {
            if (temp == null) {
                return;
            }
            System.out.println(temp);
            //指针下移
            temp = temp.next;
        }
    }
    
    // 测试
    public static void main(String[] args) {
        Node n1 = new Node(1, "张飞");
        Node n2 = new Node(2, "关羽");
        Node n3 = new Node(3, "赵云");
        Node n4 = new Node(4, "黄忠");
        Node n5 = new Node(5, "马超");
        SingleLinkedList sll = new SingleLinkedList();
        sll.addByIdOrder(n4);
        sll.addByIdOrder(n5);
        sll.addByIdOrder(n1);
        sll.addByIdOrder(n2);
        sll.addByIdOrder(n3);
        sll.showList();
    }
}
```

```java
public class Node {
    int id;
    String name;
    //下一个节点
    Node next;
    
    public Node(int id, String name) {
        this.id = id;
        this.name = name;
    }
    
    @Override
    public String toString() {
        return "Node{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}
```

### 3.栈

#### 3.1 概念

栈（stack）是一种线性数据结构，栈中的元素只能**先入后出**（First In Last Out，简称FILO）。最早进入的元素存放的位置叫作**栈底**（bottom），最后进入的元素存放的位置叫作**栈顶** （top）。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101225449057.png" alt="image-20210101225449057" style="zoom:42%;" />

- 栈（Stack）：只允许在一端进行插入或删除操作的线性表；
- 栈顶（Top）：线性表允许进行插入和删除的那一端；
- 栈底（Bottom）：固定的，不允许进行插入和删除的另一端；
- 压栈：栈的插入操作，叫做进栈，也称压栈、入栈；
- 弹栈：栈的删除操作，也叫做出栈。

**存储原理**：栈既可以用数组来实现，也可以用链表来实现。

- 栈的数组实现如下：数组实现的栈也叫顺序栈或静态栈。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101224803790.png" alt="image-20210101224803790" style="zoom:67%;" />

- 栈的链表实现如下：链表实现的栈也叫做链式栈或动态栈。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101224832752.png" alt="image-20210101224832752" style="zoom:67%;" />

**栈的应用**：函数调用、浏览器的前进与后退（两个栈）、括号匹配、表达式计算和模拟递归等。

#### 3.2 常见操作

**入栈和出栈的时间复杂度都是O(1)，查询时间复杂度为O(n)。对于支持动态扩容的顺序栈，入栈操作扩容时时间复杂度是O(n)**。

**入栈**（压栈）：入栈操作（push）就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101225931992.png" alt="image-20210101225931992" style="zoom:67%;" />

**出栈**（弹栈）：出栈操作（pop）就是把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101230021736.png" alt="image-20210101230021736" style="zoom:67%;" />

**常用操作**：

- 进栈：栈顶本来指向的节点交由新节点来指向；栈顶指针指向新节点。
- 遍历栈：只要栈顶元素的指针不指向栈底，那么就一直输出遍历结果。
- 判断该栈是否为空：只要栈顶和栈底是同一指向，那么该栈就为空。
- 出栈：将栈顶的元素的指针(指向下一个节点)赋值给栈顶指针(完成出栈)。
- 清空栈：栈顶指向栈底，就清空栈了。

#### 3.3 代码实现

使用数组实现：

```java
/**
 * @author zlg
 * @create 数组实现栈
 */
public class ArrayStack {
    
    private int[] nums; // 数组
    private int count; // 栈中元素个数
    
    // 初始化数组，申请一个大小为n的数组空间
    public ArrayStack(int n) {
        this.nums = new int[n];
        this.count = 0;
    }
    
    // 入栈操作
    public boolean push(int n) {
        // 数组空间不够了，直接返回false，入栈失败。 没有扩容
        // nums.len*2 arraycopy
        if (count >= nums.length) return false;
        // 将item放到下标为count的位置，并且count加一
        nums[count] = n;
        count++;
        return true;
    }
    
    // 出栈操作
    public int pop() {
        // 栈为空，则直接返回0
        if (count == 0) return 0;
        // 返回下标为count-1的数组元素，并且栈中元素个数count减一
        int n = nums[count - 1];
        count--;
        return n;
    }
    
    // 测试
    public static void main(String[] args) {
        ArrayStack as = new ArrayStack(8);
        as.push(3);
        as.push(5);
        as.push(1);
        as.push(4);
        System.out.println(as.pop());
        System.out.println(as.pop());
        System.out.println(as.pop());
        System.out.println(as.pop());
    }
}
```

使用链表实现：

```java
/**
 * @author zlg
 * @create 链表实现栈
 */
public class LinedStack {
    
    int size;
    Node head; //头节点
    
    // 初始化
    public LinedStack() {
        head = null;
        size = 0;
    }
    
    // 入栈
    public void push(Node node) {
        //head
        if (size == 0) {
            head = node;
        }
        //非head
        else {
            node.next = head;
            head = node;
        }
        size++;
    }
    
    // 出栈
    public Node pop() {
        if (size > 0) {
            Node oldHead = head;
            head = head.next;
            size--;
            return oldHead;
        } else {
            return null;
        }
    }
    
    // 测试
    public static void main(String[] args) {
        Node n1 = new Node(3);
        Node n2 = new Node(5);
        Node n3 = new Node(1);
        Node n4 = new Node(4);
        LinedStack ls = new LinedStack();
        ls.push(n1);
        ls.push(n2);
        ls.push(n3);
        ls.push(n4);
        System.out.println(ls.pop().value);
        System.out.println(ls.pop().value);
        System.out.println(ls.pop().value);
        System.out.println(ls.pop().value);
    }
}
```

```java
public class Node {
    
    int value;
    Node next;
    
    public Node(int value) {
        this.value = value;
    }
}
```

### 4.队列

#### 4.1 概念

队列（queue）是一种线性数据结构，只允许在一端进行插入，而在另一端进行删除的线性表，队列中的元素只能**先入先出**（First In First Out，简称 FIFO）。队列的出口端叫作**队头**（front），队列的入口端叫作**队尾**（rear）。

- 队头（Front）：允许删除的一端，又称为队首；
- 队尾（Rear）： 允许插入的一端；
- 队列：先进入队列的元素必然先离开队列，即先进先出（FIFO）。

**存储原理**：队列这种数据结构既可以用数组来实现，也可以用链表来实现。

- 数组实现：为了入队操作的方便，把队尾位置规定为最后入队元素的下一个位置。用数组实现的队列叫作**顺序队列**。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101231741166.png" alt="image-20210101231741166" style="zoom:70%;" />

- 链表实现：用链表实现的队列叫作**链式队列**。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101231806075.png" alt="image-20210101231806075" style="zoom:69%;" />

**队列应用**：资源池、LRU Cache、生产者消费者模型（消息队列、命令队列）、网络数据传输等等。

常用的队列还有双端队列（Deque）、优先队列和循环队列。

**双端队列**：双端队列是指允许两端都可以进行入队和出队操作的队列。添加、删除时间复杂度都为O(1)，查询为O(n)。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101232431065.png" alt="image-20210101232431065" style="zoom:60%;" />

**优先队列**：带有优先级的队列，优先级高的先出队列，优先级相同的遵守先进先出规则。使用**二叉堆**来实现优先队列时，入队和出队的时间复杂度都是O(logn)。

- 最大优先队列，无论入队顺序，当前最大的元素优先出队；
- 最小优先队列，无论入队顺序，当前最小的元素优先出队.

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101232607083.png" alt="image-20210101232607083" style="zoom:60%;" />

**循环队列**：使用数组实现，首尾相连的顺序存储的队列就叫循环队列。添加、删除时间复杂度都为O(1)，查询为O(n)。入队： `rear=(rear+1)%MaxSize` ，出队： `front=(front+1)%MaxSize` 。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101233153943.png" alt="image-20210101233153943" style="zoom:60%;" />

循环队列队满和队空的判断：

- 设计一个标记flag：初始flag置为0，入队列成功flag=1，出队列成功flag置为0；队空条件 `rear==front&&flag=0`；队满条件 `rear==front&&flag=1`。
- 少用一个存储空间：判空条件是尾和头相等；队尾指针加一等于队头指针就是队列满的判断条件。
- 设置一个计数器：初始时count=0,入队列成功， `count+1`,出队列成功 `count-1`；队列空的条件 `count==0`；队列满的条件 `count>0&&rear==front`或者 `count == MaxSize`。

#### 4.2 常见操作

**入队和出队时间复杂度都是O(1)**。

- 入队（enqueue）：就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101233803570.png" alt="image-20210101233803570" style="zoom:67%;" />

- 出队（dequeue）：就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101233838816.png" alt="image-20210101233838816" style="zoom:67%;" />

**常见操作**：

- 判断队列是否满了：如果rear指针和front指针紧挨着，那么说明队列就满了。
- 入队：判断该队列是否满了；入队的值插入到队尾中(具体的位置就是rear指针的位置【再次声明：rear指向的是无效元素的位置】；rear指针移动(再次指向无效的元素位置)。
- 遍历：只要front节点不指向rear节点，那么就可以一直输出。
- 判断该队列是否为空：只要rear和front指针指向同一个位置，那该队列就是空的了。
- 出队：判断该队列是否为null；如果不为null，则出队，只要front指针往后面移就是出队了。

#### 4.3 代码实现

数组实现队列：

```java
/**
 * @author zlg
 * @create 用数组实现的队列
 */
public class ArrayQueue {
    
    // 数组：items，数组大小：n
    int[] nums;
    // head表示队头下标，tail表示队尾下标
    int head = 0;
    int tail = 0;
    
    // 申请一个大小为capacity的数组
    public ArrayQueue(int size) {
        nums = new int[size];
    }
    
    // 入队
    public boolean enqueue(int n) {
        // 如果tail == n 表示队列已经满了
        if (tail == nums.length) return false;
        nums[tail] = n;
        ++tail;
        return true;
    }
    
    // 出队
    public int dequeue() {
        // 如果head == tail 表示队列为空
        if (head == tail) return 0;
        int ret = nums[head];
        ++head;
        return ret;
    }
    
    // 测试
    public static void main(String[] args) {
        ArrayQueue aq = new ArrayQueue(8);
        aq.enqueue(3);
        aq.enqueue(5);
        aq.enqueue(1);
        aq.enqueue(4);
        System.out.println(aq.dequeue());
        System.out.println(aq.dequeue());
        System.out.println(aq.dequeue());
        System.out.println(aq.dequeue());
    }
}
```

链表实现队列：

```java
/**
 * @author zlg
 * @create 链表实现
 */
public class LinkedQueue {
    
    Node head;  // 队头
    Node tail;  // 队尾
    int size;
    
    // 入队
    public void enqueue(Node node) {
        if (tail == null) {
            head = node;
            tail = node;
        } else {
            tail.next = node;
            tail = node;
        }
        size++;
    }
    
    // 出队
    public Node dequeue() {
        if (head == null) return null;
        Node h = head;
        //将拉取的节点的下一个节点变成新的表头
        head = head.next;
        //把旧的表头的下一个节点指向设置为null，让gc回收
        h.next = null;
        //队列为空
        if (head == null)
            tail = null;
        size--;
        return h;
    }
    
    // 测试
    public static void main(String[] args) {
        Node n1 = new Node(3);
        Node n2 = new Node(5);
        Node n3 = new Node(1);
        Node n4 = new Node(4);
        LinkedQueue lq = new LinkedQueue();
        lq.enqueue(n1);
        lq.enqueue(n2);
        lq.enqueue(n3);
        lq.enqueue(n4);
        System.out.println(lq.dequeue().value);
        System.out.println(lq.dequeue().value);
        System.out.println(lq.dequeue().value);
        System.out.println(lq.dequeue().value);
    }
}
```

```java
public class Node {
    
    int value;
    Node next;
    
    public Node(int value) {
        this.value = value;
    }
}
```

## 三.数据结构之散列表

### 1.概念

散列表也叫作**哈希表**（hash table），这种数据结构提供了**键**（Key）和**值**（Value）的映射关系。只要给出一个Key，就可以高效查找到它所匹配的Value，时间复杂度接近于**O(1)**。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210101235559144.png" alt="image-20210101235559144" style="zoom:60%;" />

**存储原理**：散列表在本质上也是一个**数组**，散列表的Key则是以字符串类型为主的，通过hash函数把Key和数组下标进行转换，作用是**把任意长度的输入通过散列算法转换成固定类型、固定长度的散列值**。

如下面最简单的计算方式：

```java
//数组下标=取key的hashcode模数组的长度后的余数
index = HashCode (Key) % Array.length
int index=Math.abs("Hello".hashCode())%10;
```

还有很多hash函数：CRC16、CRC32、siphash 、murmurHash、times 33等。此种Hash计算方式为固定Hash方式，也称为**传统Hash**。传统Hash法虽然比较简单，但不利于扩展（需要重新计算数组下标），如果要扩展可以采用**一致性Hash法**。

哈希表优缺点：读写快。哈希表中的元素是没有被排序的、Hash冲突、扩容 重新计算。

### 2.常见操作

写操作时间复杂度： O(1) + O(m) = O(m) ，m为单链元素个数；读操作时间复杂度：O(1) + O(m) ，m为单链元素个数；Hash冲突写/读单链表：O(m)，m为单链元素个数；Hash扩容：O(n)， n是数组元素个数 rehash。

**写操作**（put）：在散列表中插入新的键值对（在JDK中叫作Entry或Node）。通过哈希函数，把Key转化成数组下标；如果数组下标对应的位置没有元素，就把这个Entry填充到数组下标的位置。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102001601402.png" alt="image-20210102001601402" style="zoom:67%;" />

**Hash冲突**（碰撞）：由于数组的长度是有限的，当插入的Entry越来越多时，**不同的Key通过哈希函数获得的下标有可能是相同的**，这种情况，就叫作**哈希冲突**。解决哈希冲突的方法主要有两种：

- **开放寻址法**：当一个Key通过哈希函数获得对应的数组下标已被占用时，就寻找下一个空档位置。在Java中，ThreadLocal所使用的就是开放寻址法。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102001842580.png" alt="image-20210102001842580" style="zoom:50%;" />

- **拉链法**：数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可，默认next指向null。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102002029458.png" alt="image-20210102002029458" style="zoom:50%;" />

​        在Entry中保存key和值，以及next指针：

```jaVA
Entry{
    int key;
    Object value;
    Entry next;
}
```

**读操作**（get）：通过给定的Key，在散列表中查找对应的Value。通过哈希函数，把Key转化成数组下标；找到数组下标所对应的元素，若key不正确，说明产生了hash冲突，则顺着头节点遍历该单链表，再根据key即可取值。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102002617132.png" alt="image-20210102002617132" style="zoom:67%;" />

**Hash扩容**（resize）：散列表是基于数组实现的，所以散列表需要扩容。当经过多次元素插入，散列表达到一定饱和度时，Key映射位置发生冲突的概率会逐渐提高。这样一来，大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。

影响扩容的因素有两个：**Capacity**（HashMap的当前长度）、**LoadFactor**（HashMap的负载因子（阈值），默认值为0.75f）。当 `HashMap.Size >= Capacity×LoadFactor`时，需要进行扩容 。

扩容步骤：1.扩容，创建一个新的Entry空数组，长度是原数组的2倍；2.重新Hash，遍历原Entry数组，把所有的Entry重新Hash到新数组中。JDK1.8前在HashMap扩容时，会**反序单链表**，这样在高并发时会有死循环的可能。

### 3.代码实现

Node节点：

```java
public class Node {
    String key;
    String value;
    //指向下一个结点
    Node next;

    public Node(String key, String value, Node next) {
        this.key = key;
        this.value = value;
        this.next = next;
    }
}
```

单链表：

```java
public class ListNode {
    Node head; //头结点

    // 添加单链表结点
    public void addNode(String key, String value) {
        //在外界设置好head了
        if (head == null) return;
        //   创建结点
        Node node = new Node(key, value, null);
        //  临时变量
        Node tmp = head;

        //循环单链表
        while (true) {
                       //key相同覆盖值 从head开始
            if(key.equals(tmp.key)){
                tmp.value=value;
            }

            if(tmp.next==null){
                break;
            }

            //指向下一个
            tmp=tmp.next;
        }
        //在循环外挂载最后一个结点
        tmp.next=node;

    }

    // 获得值
    public String getVal(String key) {
        if (head == null) return null;
        //只有一个结点
        if (head.next == null) {
            return head.value;
        }
        //遍历单链表
        else {
            Node tmp = head;
            while (tmp != null) {
                //找到匹配的key
                if (key.equals(tmp.key)) {
                    return tmp.value;
                }
                //指向下一个
                tmp = tmp.next;
            }
            return null;
        }

    }
}
```

手动HashMap：

```java
public class MyHashMap {
    
    //数组初始化 2的n次方
    ListNode[] map = new ListNode[8];
    //ListNode的个数
    int size;
    
    // 设置值
    public void put(String key, String value) {
        //该扩容了
        if (size >= map.length * 0.75) {
            System.out.println("map需要扩容");
            return;
        }
        //计算索引 数组下标
        int index = Math.abs(key.hashCode()) % map.length;
        //获得该下标处的ListNode
        ListNode ln = map[index];
        
        //该下标处无值
        if (ln == null) {
            //创建单链表
            ListNode lnNew = new ListNode();
            //创建头结点
            Node head = new Node(key, value, null);
            //挂载头结点
            lnNew.head = head;
            //把单链放到数组里
            map[index] = lnNew;
            size++;
        }
        //该下标有值，hash碰撞
        else {
            //单链表挂结点
            ln.addNode(key, value);
        }
        
    }
    
    // 取值
    public String get(String key) {
        int index = Math.abs(key.hashCode()) % map.length;
        ListNode ln = map[index];
        if (ln == null) return null;
        return ln.getVal(key);
        
    }
    
    // 测试
    public static void main(String[] args) {
        MyHashMap hashMap = new MyHashMap();
        hashMap.put("m3", "cccccc");
        hashMap.put("c1", "kkkkkk");
        hashMap.put("c1", "mmmmmmm");
        System.out.println(hashMap.get("c1"));
    }
}
```

### 4.哈希表应用

#### 4.1 HashMap

JDK1.7中HashMap使用一个table数组来存储数据，用key的hashcode取模来决定key会被放到数组里的位置，如果hashcode相同，或者hashcode取模后的结果相同，那么这些key会被定位到Entry数组的同一个格子里，这些key会形成一个链表，在极端情况下比如说所有key的hashcode都相同，将会导致这个链表会很长，那么put/get操作需要遍历整个链表，那么最差情况下时间复杂度变为O（n）。

针对JDK1.7中的这个性能缺陷，JDK1.8中的table数组中可能存放的是链表结构，也可能存放的是红黑树结构，如果链表中节点数量不超过8个则使用链表存储，超过8个会调用treeifyBin函数，将链表转换为红黑树。那么即使所有key的hashcode完全相同，由于红黑树的特点，查找某个特定元素，也只需要O（logn）的开销。

![image-20201025230003234](https://gitee.com/itzlg/mypictures/raw/master/img/image-20201025230003234.png)

关于HashMap底层原理介绍推荐：[HashMap底层实现](http://itzlg.gitee.io/java-interview/#/docs/%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98?id=_6hashmap%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0)

#### 4.2 字典

Redis字典dict又称散列表（hash），是用来存储键值对的一种数据结构。Redis整个数据库是用字典来存储的（K-V结构）。Redis字典实现包括：字典(dict)、Hash表(dictht)、Hash表节点(dictEntry)。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102005619107.png" alt="image-20210102005619107" style="zoom:50%;" />

#### 4.3 布隆过滤器

布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的**二进制向量和一系列随机hash映射函数**。布隆过滤器可以用于**检索一个元素是否在一个集合中**。它的优点是空间效率和查询时间都远远超过一般的算法。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102005835076.png" alt="image-20210102005835076" style="zoom:67%;" />

布隆过滤器的原理是，**当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个数组中的K个点，把它们置为1**。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。

#### 4.4 位图

Bitmap 的基本原理就是**用一个 bit 来标记某个元素对应的 Value**，而 Key 即是该元素。由于采用一个bit 来存储一个数据，因此可以大大的节省空间。

Java 中 int 类型占用 4 个字节，即 4 byte，又 1 byte = 8 bit，所以 一个 int 数字的表示大概如下：

![image-20210102010132296](https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102010132296.png)

使用 bit 来表示数组 [1, 2, 5] 如下所示，可以看到只用 1 字节即可表示：

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102010921337.png" alt="image-20210102010921337" style="zoom:60%;" />

## 四.数据结构之树和图

### 1.树的概念

有很多数据的逻辑关系并不是线性关系，在实际场景中，常常存在着一对多，甚至是多对多的情况。如家谱、公司组织结构、书的目录。在数据结构中，树的定义如下：**树（tree）是n（n≥0）个节点的有限集**。当n=0时，称为空树。在任意一个非空树中，有如下特点：

- 有且仅有一个特定的称为根的节点；
- 当n>1时，其余节点可分为m（m>0）个互不相交的有限集；
- 每一个集合本身又是一个树，并称为根的子树。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102213141088.png" alt="image-20210102213141088" style="zoom:50%;" />

树是递归定义的结构。关于**节点**的概念：

- 结点（node)： 存储数据元素和指向子树的链接，由数据元素和构造数据元素之间关系的引用组成；
- 根节点（root): 树顶端的节点称之为根节点，也叫树根；
- 子结点： 树中一个结点的子树的根结点称为这个结点的子结点；
- 叶子结点： 度为0的结点称为叶子结点，也叫终端结点；
- 子树(subTree): 除根节点之外，其他节点可以分为多个树的集合，叫做子树。

关于**度**的概念：

- 树的度： 树中所有结点的度的最大值称为树的度；
- 结点的度： 结点所有子树的个数称为该结点的度；

树的最大层级数，被称为**树的高度或深度**。

![image-20210102213714373](https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102213714373.png)

树的高度（深度）：树中结点的最大层数。

- 节点的层次： 从根结点到树中某结点所经路径的分支数称为该结点的层次；
- 节点的高度： 从叶节点开始、自底向上逐层累加（叶节点的高度是0）助记：高度由下向上；
- 节点的深度： 从根节点开始、自顶向下逐层累加（根节点的高度是0）助记：深度从上到下。

### 2.二叉树

#### 2.1 二叉树

二叉树（Binary Tree）是一种树形数据结构，它的**每个节点最多有两个子节点**，被叫作左子树（left child）和右子树（right child），这两个子节点的顺序是固定的，**左子树小于右子树**，每个节点的度小于3。注意：这里是最多有2个，也可能只有1个，或者没有孩子节点。

二叉树特点：

- 至少有一个节点(根节点)；
- 每个节点最多有两颗子树，即每个节点的度小于3；左子树和右子树是**有顺序的**，次序不能任意颠倒；
- 即使树中某节点只有一棵子树，也要区分它是左子树还是右子树；
- 顺序和链式都可以实现。

**满二叉树**：所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102215207372.png" alt="image-20210102215207372" style="zoom:30%;" />

**完全二叉树**（Complete binary tree）：如果二叉树中除去底层节点后为满二叉树，且底层节点依次从左到右分布（它不满的那部分一定在右下侧），则称为完全二叉树。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102215400013.png" alt="image-20210102215400013" style="zoom:30%;" />

**满二叉树要求所有分支都是满的；而完全二叉树只需保证最后分布的节点之前的节点都齐全即可**。

**二叉树的存储**：二叉树属于逻辑结构，可以使用链表和数组进行存储。

- 链式存储：二叉树的每一个节点包含3部分：存储数据的data变量、指向左孩子的left指针、指向右孩子的right指针。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102220404153.png" alt="image-20210102220404153" style="zoom:36%;" />

- 数组存储：按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102220631338.png" alt="image-20210102220631338" style="zoom:36%;" />

数组存储寻址方式：一个父节点的下标是n，那么它的左孩子节点下标就是2×n+1、右孩子节点下标就是2*(n+1)。

对于一个稀疏的二叉树（孩子不满）来说，用数组表示法是非常浪费空间的，所以**二叉树一般用链表存储实现**。（二叉堆除外）

#### 2.2 二叉树的遍历

二叉树，是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性的序列，以不同的方式来遍历，遍历出的序列顺序也不同。二叉树的**插入和查找**时间复杂度为:O(logn)，极端情况下二叉树退化成链表，时间复杂度为O(n)，所以需要平衡二叉查找树。

二叉树的遍历包括深度优先搜索（DFS）和广度优先搜索（BFS）。每个节点都要访问一次；每个节点仅仅要访问一次；对于节点的访问顺序不限。

##### 2.2.1 深度优先搜索（DFS）

深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方式。它包括：

**前序遍历**（Pre-order）：输出顺序是根节点、左子树、右子树

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102223220486.png" alt="image-20210102223220486" style="zoom:33%;" />

**中序遍历**（In-order）：输出顺序是左子树、根节点、右子树

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102223335498.png" alt="image-20210102223335498" style="zoom:33%;" />

**后序遍历**（Post-order）：输出顺序是左子树、右子树、根节点

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102223431022.png" alt="image-20210102223431022" style="zoom:33%;" />

##### 2.2.2 广度优先搜索（BFS）

层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102224647866.png" alt="image-20210102224647866" style="zoom:33%;" />

二叉树同一层次的节点之间是没有直接关联的，利用队列可以实现。

1. 根节点1进入队列；
2. 节点1出队，输出节点1，并得到节点1的左孩子节点2、右孩子节点3。让节点2和节点3入队；
3. 节点2出队，输出节点2，并得到节点2的左孩子节点4、右孩子节点5。让节点4和节点5入队；
4. 节点3出队，输出节点3，并得到节点3的右孩子节点6。让节点6入队；
5. 节点4出队，输出节点4，由于节点4没有孩子节点，所以没有新节点入队；
6. 节点5出队，输出节点5，由于节点5同样没有孩子节点，所以没有新节点入队；
7. 节点6出队，输出节点6，节点6没有孩子节点，没有新节点入队。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102230222763.png" alt="image-20210102230222763" style="zoom:33%;" />

##### 2.2.3 代码实现

树的节点TreeNode：

```java
// 树节点
public class TreeNode {
    //值
    int data;
    //左孩子
    TreeNode leftChild;
    //右孩子
    TreeNode rightChild;

    public TreeNode(int data) {
        this.data = data;
    }
}
```

BinaryTree遍历：

```java
/**
 * 二叉树遍历
 */
public class BinaryTree {
    // 根节点
    TreeNode root;
    
    /**
     * 插入数据
     * @param data
     */
    public void insertNode(int data) {
        root = insert(root, data);
    }
    // 递归插入节点
    private TreeNode insert(TreeNode node, int data) {
        //结束条件
        if (node == null) return new TreeNode(data); 
        //左孩子
        if (data < node.data) {
            node.leftChild = insert(node.leftChild, data);
        }
        //右孩子
        else if (data > node.data) {
            node.rightChild = insert(node.rightChild, data);
        }
        //自己
        else {
            node.data = data;
        }
        return node;
    }
    
    /**
     * 前序遍历  根 左 右
     * @param node
     */
    public void beforeTraver(TreeNode node) {
        //结束条件
        if (node == null) return;
        System.out.println(node.data); //节点
        beforeTraver(node.leftChild); //左孩子
        beforeTraver(node.rightChild); //右孩子
    }
    
    /**
     * 中序遍历  左 根 右
     * @param node
     */
    public void midTraver(TreeNode node) {
        //结束条件
        if (node == null) return;
        midTraver(node.leftChild);
        System.out.println(node.data);
        midTraver(node.rightChild);
    }
    
    /**
     * 后序遍历  左 右 根
     * @param node
     */
    public void afterTraver(TreeNode node) {
        //结束条件
        if (node == null) return;
        afterTraver(node.leftChild);
        afterTraver(node.rightChild);
        System.out.println(node.data);
    }
    
    /**
     * 广度遍历
     * @param root
     */
    public void levelTraver(TreeNode root) {
        //队列
        Queue<TreeNode> queue = new LinkedList<>();
        //从队尾入队
        queue.offer(root);
        //队列不为空
        while (!queue.isEmpty()) {
            //出队   队头出并删除
            TreeNode node = queue.poll();
            System.out.println(node.data);
            //左孩子入队
            if (node.leftChild != null) {
                queue.offer(node.leftChild);
            }
            //右孩子入队
            if (node.rightChild != null) {
                queue.offer(node.rightChild);
            }
        }
        
    }
  
    // 测试
    public static void main(String[] args) {
        BinarySerachTree bst = new BinarySerachTree();
        bst.insertNode(10);
        bst.insertNode(8);
        bst.insertNode(11);
        bst.insertNode(7);
        bst.insertNode(9);
        bst.insertNode(12);
        
        bst.beforeTraver(bst.root);
        System.out.println("===========================");
        bst.midTraver(bst.root);
        System.out.println("=============================");
        bst.afterTraver(bst.root);
        System.out.println("==============================");
        bst.levelTraver(bst.root);
    }
}
```

#### 2.3 二叉搜索树

二叉搜索树（Binary Search Tree）也称有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree）。二叉查找树在二叉树的基础上增加了以下几个条件：

- 如果左子树不为空，则左子树上所有节点的值均**小于**根节点的值；
- 如果右子树不为空，则右子树上所有节点的值均**大于**根节点的值；
- 左、右子树也都是**二叉查找树**。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102221102306.png" alt="image-20210102221102306" style="zoom:33%;" />

二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性，只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。**无法根据节点的结构改变(添加或删除)动态平衡树的排序结构，对某些操作的效率造成一定的影响**。

**查找操作**：二叉查找树的查询效率介于 `O(logn)~O(n)`之间。例如查找值为4的节点，步骤如下：

1. 访问根节点6，发现4<6。
2. 访问节点6的左孩子节点3，发现4>3。
3. 访问节点3的右孩子节点4，发现4=4，这正是要查找的节点。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102221508592.png" alt="image-20210102221508592" style="zoom:33%;" />

对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是O(logn)，和树的深度是一样的。这种方式正是二分查找思想。

**插入操作**：例如插入新元素5，步骤如下：

1. 访问根节点6，发现5<6；
2. 访问节点6的左孩子节点3，发现5>3；
3. 访问节点3的右孩子节点4，发现5>4；
4. 5最终会插入到节点4的右孩子位置。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210102222049443.png" alt="image-20210102222049443" style="zoom:33%;" />

**删除操作**：删除节点操作不同情况。

- 删除节点的度为0，则直接删除；
- 删除节点的度为1，则该子节点替代删除节点；
- 删除节点的度为2，则从左子树中寻找值最大的节点替代删除节点。

#### 2.4 红黑树

在介绍红黑树之前先看下图的二叉查找树，如下图：

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103010432484.png" alt="image-20210103010432484" style="zoom:36%;" />

这种二叉查找树就退化成了链表，由于树的深度变得多了，查找的效率也会大幅下降，所以需要对这种二叉树进行自平衡。**红黑树就是一种自平衡的二叉查找树**。

在介绍红黑树之前先初步了解一下平衡查找树 **2-3树**。

##### 2.4.1 平衡查找树之2-3树

**2-3树**满足二叉搜索树的性质，且节点可以存放一个元素或者两个元素，每个节点有两个或三个孩子的树。相比二叉搜索树，2-3树的节点可能存放 2 个元素，而且每个节点可能拥有 3 个子节点。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103013733124.png" alt="image-20210103013733124" style="zoom:50%;" />

2-3树具有以下性质：

- **对于2-节点**：含有一个元素和两个子树（左右子树），左子树所有元素的值均小于它父节点，右子树所有元素的值均大于它父节点；
- **对于3-节点**：还有两个元素和三个子树（左中右子树），左子树所有元素的值均小于它父节点，中子树所有元素的值都位于父节点两个元素之间，右子树所有元素的值均大于它父节点。

2-3树创建规则：

- 规则1. 加入新节点时，不会往空的位置添加节点，而是添加到最后一个叶子节点上 ；
- 规则2. 四节点可以被分解三个2-节点组成的树，并且分解后新树的根节点需要向上和父节点融合。

2-3树这种每个节点储存1~2个元素以及拆分节点向上融合的性质不便于代码操作。通过一些规则，将2-3树转换成二叉树，且转换后的二叉树依然能保持平衡性，所以就还需要一颗红黑树来实现。

**2-3树和红黑树的等价性**：

- 2-节点：直接转换为红黑树的一个黑节点；
- 3-节点：将3-节点拆开，成为一棵树，并且3-节点的左元素作为右元素的子树；将原来的左元素标记为红色（表示红色节点与其父节点在2-3树中曾是平级的关系）。

##### 2.4.3 红黑树

**红黑树**（Red Black Tree）是一种自平衡二叉搜索树，**从根到叶子节点的最长路径不会超过最短路径的2倍**。除了二叉查找树(BST)的特征外，还有以下特征：

- **每个节点要么是黑色，要么是红色**；
- **根节点总是黑色的**：根节点要么对应2-3树的2-节点或者3-节点，而这两者的根节点都是黑色的，因而根节点必然是黑色；
- **每个叶子节点都是黑色的空结点**（NIL结点）：这里的叶子是指的为空的叶子节点；
- 如果一个节点是红色的，则它的子节点必须是黑色的（**父子不能同为红**）：红黑树的每个节点都由2-3树转换而来，红色节点连接的节点必然是一个2-节点或者3-节点，而无论是2-节点还是3-节点，其根节点都是黑色的，因此红色节点的子节点必然是黑色的；
- **从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点**（平衡的关键）：红黑树最重要的一条性质，也是红黑树的价值所在。由于红黑树是由2-3树转换而来，因此每一个黑色节点必然对应2-3树的某个2-节点或者3-节点，因此红黑树的黑节点也能拥有2-3树的平衡性；
- **新插入节点默认为红色**，插入后需要校验红黑树是否符合规则，不符合则需要进行平衡：往2-3树插入节点时做的都是融合，因此新加入的节点和原位置的节点是平级关系，所以我们往红黑树里增加节点的时候，增加的都是红色节点。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103015100470.png" alt="image-20210103015100470" style="zoom:50%;" />

在对红黑树进行**添加或者删除操作**时可能会破坏这些特点，所以红黑树采取了很多方式来维护这些特点，从而维持平衡。主要包括：**左旋转、右旋转和颜色反转**。

- 插入节点：红黑树插入节点后违反的主要规则是**两个连续的红色节点**；
- 删除节点：删除节点主要违反的规则是**子树中黑色高度的更改**，导致根节点到叶子路径的黑色高度降低。

**左旋**（RotateLeft）：**逆时针**旋转红黑树的两个结点，使右孩子取代自己的父结点，而父节点成为左孩子。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103015834354.png" alt="image-20210103015834354" style="zoom:33%;" />

**右旋**（RotateRight）：**顺时针**旋转红黑树的两个结点，使左孩子取代自己的父结点，而父节点成为右孩子。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103020608835.png" alt="image-20210103020608835" style="zoom:33%;" />

**颜色反转**：当前节点与父节点、叔叔节点同为红色，这种情况违反了红黑树的规则，需要将红色向祖辈上传，父节点和叔叔节点红色变为黑色，爷爷节点从黑色变为红色。这样保证了每个叶子结点到根节点的黑色节点数量未发生变化。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103021211694.png" alt="image-20210103021211694" style="zoom:33%;" />

红黑树插入有五种情况，每种情况对应着不同的调整方法：

1. 新结点（A）位于**树根**，没有父结点：直接让新结点变色为黑色。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103021542177.png" alt="image-20210103021542177" style="zoom:33%;" />

2. 新结点（B）的**父结点是黑色**：不需要做任何调整。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103021613759.png" alt="image-20210103021613759" style="zoom:33%;" />

3. 新结点（D）的**父结点和叔叔结点都是红色**：父节点和叔叔节点变为黑色，爷爷节点变为红色。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103022016016.png" alt="image-20210103022016016" style="zoom:33%;" />

4. 新结点（D）的**父结点是红色**，**叔叔结点是黑色**或者没有叔叔，且新结点是父结点的**右孩子**，父结点（B）是祖父结点的**左孩子**：以结点B为轴，做一次左旋转，使得新结点D成为父结点，原来的父结点B成为D的左孩子。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103022358698.png" alt="image-20210103022358698" style="zoom:33%;" />

5. 新结点（D）的**父结点是红色**，**叔叔结点是黑色**或者没有叔叔，且新结点是父结点的**左孩子**，父结点（B）是祖父结点的**左孩子**：以结点A为轴，做一次右旋转，使得结点B成为祖父结点，结点A成为结点B的右孩子，然后让结点B变为黑色，结点A变为红色。

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103023004113.png" alt="image-20210103023004113" style="zoom:33%;" />

**红黑树构建过程**，如下列图：

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103024128565.png" alt="image-20210103024128565" style="zoom:70%;" />

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103024247433.png" alt="image-20210103024247433" style="zoom:70%;" />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210103024610820.png" alt="image-20210103024610820" style="zoom:70%;" />

<img src="https://gitee.com/itzlg/mypictures/raw/master/img/image-20210103025028432.png" alt="image-20210103025028432" style="zoom:70%;" />

**红黑树查找操作时间复杂度为**O(logn)。在JDK1.8中HashMap使用数组+链表+红黑树的数据结构。内部维护着一个数组table，该数组保存着每个链表的表头结点或者树的根节点。HashMap存储数据的数组定义如下，里面存放的是Node<K,V>实体：

```java
// 序列化时不自动保存
transient Node<K, V>[] table;  

// 桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 > 该值时，则将链表转换成红黑树
static final int TREEIFY_THRESHOLD = 8;
```

##### 2.4.3 红黑树代码实现

红黑树节点：

```java
// 红黑树结点
public class RBTreeNode {
    private int key;
    private boolean isBlack;
    private RBTreeNode left;
    private RBTreeNode right;
    private  RBTreeNode parent;

    public RBTreeNode(int key) {
        this.key = key;
        isBlack=false;// 新增节点默认为红色
    }
	// 省略set/get方法...
}
```

红黑树：

```java
// 红黑树
public class RBTree {
    RBTreeNode root;//根节点
    
    /**
     * 遍历节点
     * @param node
     */
    public void list(RBTreeNode node) {
        if (node == null) return;
        //递归终止条件
        if (node.getLeft() == null && node.getRight() == null) {
            System.out.println(node);
            return;
        }
        System.out.println(node);
        list(node.getLeft());
        list(node.getRight());
    }
    
    /**
     * 插入节点
     * @param key
     */
    public void insert(int key) {
        RBTreeNode node = new RBTreeNode(key);
        //插入根节点
        if (root == null) {
            node.setBlack(true);//根是黑的
            root = node;
            return;
        }
        
        RBTreeNode parent = root;
        RBTreeNode son = null;
        
        //左孩子
        if (key <= parent.getKey()) {
            son = parent.getLeft();
        }
        //右孩子
        else {
            son = parent.getRight();
        }
        //递归查找
        while (son != null) {
            parent = son;
            if (key <= parent.getKey()) {
                son = parent.getLeft();
            } else {
                son = parent.getRight();
            }
        }
        //添加左孩子
        if (key <= parent.getKey()) {
            parent.setLeft(node);
        }
        //添加右孩子
        else {
            parent.setRight(node);
        }
        node.setParent(parent);
        
        //自平衡
        balanceInsert(node);
    }
    
    // 插入自平衡
    private void balanceInsert(RBTreeNode node) {
        RBTreeNode father, gFather;
        //父节点是红的
        while ((father = node.getParent()) != null && father.isBlack() == false) {
            gFather = father.getParent();
            //父节点在祖父节点的左边
            if (gFather.getLeft() == father) {
                RBTreeNode uncle = gFather.getRight();
                if (uncle != null && uncle.isBlack() == false) {
                    //颜色反转
                    setBlack(father);
                    setBlack(uncle);
                    setRed(gFather);
                    node = gFather;
                    continue;
                }
                if (node == father.getRight()) {
                    //左旋
                    leftRotate(father);
                    //交换
                    RBTreeNode tmp = node;
                    node = father;
                    father = tmp;
                }
                setBlack(father);
                setRed(gFather);
                //右旋
                rightRotate(gFather);
                
            }
            //父节点在祖父节点右边
            else {
                RBTreeNode uncle = gFather.getLeft();
                if (uncle != null && uncle.isBlack() == false) {
                    //颜色反转
                    setBlack(father);
                    setBlack(uncle);
                    setRed(gFather);
                    node = gFather;
                    continue;
                }
                if (node == father.getLeft()) {
                    //右旋
                    rightRotate(father);
                    //交换
                    RBTreeNode tmp = node;
                    node = father;
                    father = tmp;
                }
                setBlack(father);
                setRed(gFather);
                //左旋
                leftRotate(gFather);
            }
        }
        // 设置黑色
        setBlack(root);
    }
    
    // 左旋
    private void leftRotate(RBTreeNode node) {
        RBTreeNode right = node.getRight();
        RBTreeNode parent = node.getParent();
        // root
        if (parent == null) {
            root = right;
            right.setParent(null);
        } else {
            if (parent.getLeft() != null && parent.getLeft() == node) {
                parent.setLeft(right);
            } else {
                parent.setRight(right);
            }
            right.setParent(parent);
            
        }
        node.setParent(right);
        node.setRight(right.getLeft());
        if (right.getLeft() != null) {
            right.getLeft().setParent(node);
        }
        right.setLeft(node);
    }
    
    // 右旋
    private void rightRotate(RBTreeNode node) {
        RBTreeNode left = node.getLeft();
        RBTreeNode parent = node.getParent();
        if (parent == null) {
            root = left;
            left.setParent(null);
        } else {
            if (parent.getLeft() != null && parent.getLeft() == node) {
                parent.setLeft(left);
            } else {
                parent.setRight(left);
            }
            left.setParent(parent);
        }
        node.setParent(left);
        node.setLeft(left.getRight());
        if (left.getRight() != null) {
            left.getRight().setParent(node);
        }
        left.setRight(node);
    }
    
    // 设置黑色
    private void setBlack(RBTreeNode node) {
        node.setBlack(true);
    }
    // 设置红色
    private void setRed(RBTreeNode node) {
        node.setBlack(false);
    }
    
    // 测试
    public static void main(String[] args) {
        RBTree rb = new RBTree();
        rb.insert(10);//根节点
        rb.insert(5);
        rb.insert(9);
        rb.insert(3);
        rb.insert(6);
        rb.insert(7);
        rb.insert(19);
        rb.insert(32);
        rb.insert(24);
        rb.insert(17);
        
        rb.list(rb.root);
    }
}
```

#### 2.5 二叉堆







### 3.多路树

#### 3.1 B树





#### 3.2 B+树







### 4.图















