## 运行时数据区、PC寄存器

### 一.运行时数据区内部结构

JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。**不同的JVM对于内存的划分方式和管理机制存在着部分差异**。

![image-20200710224124349](https://gitee.com/itzlg/mypictures/raw/master/img/image-20200710224124349.png)

- 每个线程独立拥有：程序计数器、虚拟机栈、本地方法栈（线程）；
- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存），永久代或方法区就是方法区的实现，与虚拟机的生命周期一致（进程）。

阿里开发手册：

![image-20200710224159662](https://gitee.com/itzlg/mypictures/raw/master/img/image-20200710224159662.png)

每个JVM只有一个Runtime实例。即为运行时环境，相当于运行时数据区。

### 二.程序计数器

#### 1.概念

JVM中程序计数寄存器（Program Counter Register）中，也可称为程序钩子，命名起源于CPU的寄存器，寄存器存储指令相关的信息。CPU只有把数据装载到寄存器才能够运行。**JVM中的PC计数器（指令计数器）是对物理PC寄存器的一种抽象模拟**。

PC寄存器用来存储指向**下一条指令的地址**，即将要执行的指令代码。由执行引擎读取下一条指令。

![image-20200710224313720](https://gitee.com/itzlg/mypictures/raw/master/img/image-20200710224313720.png)

在JVM规范中，**每个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致**。任何时间一个线程都只有一个方法在执行，也就是当前方法。**程序计数器存储当前线程正在执行的Java方法的JVM指令地址。如果是执行native方法，则是未指定值**（undefined）。

PC寄存器可理解为数据库结果集的遍历时的游标，或集合中的迭代器。**PC寄存器没有 GC 和 OOM。栈有OOM，没有GC。堆和方法区有GC和OOM**。

![image-20200710224405412](https://gitee.com/itzlg/mypictures/raw/master/img/image-20200710224405412.png)

#### 2.两个常见问题

- **2.1使用PC寄存器存储字节码指令地址有什么用**？**为什么使用PC寄存器记录当前线程的执行地址呢**？

因为CPU需要不停的切换各个线程,这时候切换回来以后,就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

- **2.2PC寄存器为什么会被设定为线程私有?**

所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法, CPU会不停地做任务切换,这样必然导致经常中断或恢复,如何保证分毫无差呢?

**为了能够准确地记录各个线程正在执行的当前字节码指令地址,最好的办法自然是为每一个线程都分配一个PC寄存器**,这样一来各个线程之间便可以进行独立计算,从而不会出现相互干扰的情况。

由于CPU时间片轮限制,众多线程在并发执行过程中,任何一个确定的时刻,一个处理器或者多核处理器中的一个内核,只会执行某个线程中的一条指令。这样必然导致经常中断或恢复,如何保证分毫无差呢?

**每个线程在创建后,都会产生自己的程序计数器和栈帧,程序计数器在各个线程之间互不影响**。

- **2.3CPU时间片**

**并发是一段时间间隔内运行多个任务（一个时间片内交替执行），并行是一个时刻运行多个任务**。

CPU时间片即CPU分配给各个程序的时间,每个线程被分配一个时间段,称作它的时间片。在宏观上:我们可以同时打开多个应用程序,每个程序并行不悖,同时运行。但在微观上:由于只有一个CPU,一次只能处理程序要求的一部分,如何处理公平,一种方法就是引入时间片,每个程序轮流执行。



