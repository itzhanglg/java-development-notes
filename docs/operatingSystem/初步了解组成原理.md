### 一.计算机是什么？边界在哪？

芯片：芯片将电能转化为计算能量，计算能量推动程序执行；

摩尔定律：了解到我们的计算能力仍在飞速发展；

**公理化体系和不完备性定理**

公理化体系：德国著名数学家希尔伯特提出这个世界可以建立一套完善的公理体系，由少数几个公理出发，推导出所有的定理和推论。

不完备性定理：美籍数学家哥德尔就提出了哥德尔不完备性定理，内容是：即便在完善的公理体系中仍然可以找到不能被证明也不能被证伪的命题。

计算机能力也是有边界的。哥德尔的不完备性定理，让大家看到了世界上还有大量不可计算的问题。

**图灵机和可计算理论**

可计算性理论：哪些问题可以被计算，哪些不可以被计算。

图灵发现如果一个问题是可计算的，那么它的解决方案就必须可以被具化成一条条的指令，也就是可以使用图灵机处理。因此，不能使用图灵机处理的问题，都是不可计算的问题。

停机问题是一个经典的不可计算问题：无法实现用一个通用程序去判断另一个程序是否会停止。

**计算能力的边界在哪里**？

可以把世界上想解决的事情都称作问题，解决问题往往需要消耗芯片的计算能力，这通常称作**时间开销**，另外解决问题还需要消耗内存，称作**空间开销**。

按照摩尔定律所说，人类的计算能力每 18～24 个月翻一倍，我们的计算能力在呈指数形式上升。有能力解决的问题，统称为**多项式时间**（ Polynomial time）问题（像 O(N^1000)的问题）。下面简称记为 P 类型的问题。

还有一类问题复杂度本身也是**指数形式**的问题，比如 O(2N)的问题。这类型的问题随着规模 N 上升，时间开销的增长速度非常快，最终可能无法解决。可以简称记为 NP 问题。

有一部分 NP 问题可以被转化为 P 问题，比如斐波那契数列求第 N 项，可以用缓存、动态规划等方式转化为 O(N) 的问题。

### 二.64位相比32位的优势是什么？

32、64位可以指操作系统、软件，也可以指CPU：

- 如果是软件，那么我们的数据库有 32 位和 64 位版本；
- 如果是操作系统，那么在阿里云上选择 Centos 和 Debian 版本的时候，也会有 32/64 版本；
- 如果是 CPU，那么有 32 位 CPU，也有 64 位 CPU。

#### 1.图灵机

图灵机在计算机科学方面有两个巨大的贡献：

- 它清楚地定义了计算机能力的边界，也就是可计算理论；
- 它定义了计算机由哪些部分组成，程序又是如何执行的。

![image-20201108103223649](https://gitee.com/itzlg/mypictures/raw/master/img/image-20201108103223649.png)

图灵机的内部构造：

- 图灵机拥有一条无限长的纸带，纸带上是一个格子挨着一个格子，格子中可以写字符，你可以把纸带看作**内存**，而这些字符可以看作是内存中的数据或者程序。
- 图灵机有一个读写头，读写头可以读取任意格子上的字符，也可以改写任意格子的字符。
- 读写头上面的盒子里是一些精密的零件，包括图灵机的**存储、控制单元和运算单元**。

图灵机构造的这一台机器，主要功能就是读写纸带然后计算；纸带中有数据、也有控制字符（也就是指令），这个设计和我们今天的计算机是一样的。

#### 2.冯诺依曼模型

![image-20201108103944279](https://gitee.com/itzlg/mypictures/raw/master/img/image-20201108103944279.png)

冯诺依曼模型对图灵机进行具体的实现：包括CPU（中央处理器），内存，总线，I/O设备。

**CPU**：CPU负责控制和运算，32和64位指的是CPU一次可运算的位(bit)数。32位(4 byte); 64位(8 byte)。

CPU中包括运算单元，控制单元和寄存器。寄存器又分为**通用寄存器**，用于用户编程使用；**特殊寄存器**，用于存储下一个要执行的指令的内存地址；读取到的指令会放到**指令寄存器**。CPU从寄存器的读取速度远远高于从内存读取。

**内存**：在冯模型中内存程序内存线性排列并存储。存储单位为bit，最小的存储单元为8个bit(1 byte)。在内存中任何位置的读写速度相同。内存地址从0开始，下一个地址为1，一直到 (内存的字节数 - 1)。

**总线**：控制CPU和内存以及其它设备之间的通信。总线分成三种：

- **地址总线**，专门用来指定 CPU 将要操作的内存地址。
- **数据总线**，用来读写内存中的数据。
- 控制总线，用来发送和接收关键信号，如中断，复位，就绪等。

当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。

**输入、输出设备**：输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。

**补充**：

数据是通过线路的高低电压进行传输的(高1,低0)，并行传递信号可提升传输效率。线路位宽限制了每次并行传输的最大信号量。如果是32位地址总线则可以操作2^32位内存(4G)。

32位宽CPU操作64位数据时，需要分为两次32位操作。32位操作系统无法控制高于32位的总线。64位相对于32位的优势：因为一次性并行传输的信号量以及CPU的处理能力从2^32 变成了 2^64，因此可以操作的数据量和内存地址范围都变成了32位的2次幂。

#### 3.程序的执行过程

CPU执行程序时：

1. CPU读取PC（程序计数器）指向的指令，将它读入到指令寄存器中。
    - CPU的控制单元将PC 指针中的值拷贝到地址总线中；
    - CPU通知内存设备准备数据，内存通过数据总线将数据传递给CPU；
    - CPU接受到数据后，将数据存入指令寄存器中。
2. CPU 分析指令寄存器中的指令，确定指令的类型和参数。如果是计算类型的指令，那么就交给逻辑运算单元计算；如果是存储类型的指令，那么由控制单元执行。
3. PC 指针自增，并准备获取下一条指令。

> 比如在 32 位的机器上，指令是 32 位 4 个字节，需要 4 个内存地址存储，因此 PC 指针会自增 4。
>
> 内存中指令区域（正文段）和存储区域（数据段）不会存放在一起，这是为了安全起见。
>
> a=11+15的CPU执行过程:首先编译器会将编写的程序编译成指令。编译器会将上面的11和15这个两个常量放到专门存储数据的区域(数据段); 同时会把上面的程序编译成四个操作指令。

指令和CPU的指令周期：

举例如load指令（16 进制：0x8c000100）导入到寄存器中，CPU进行解析为下图：

![image-20201108151722469](https://gitee.com/itzlg/mypictures/raw/master/img/image-20201108151722469.png)

最左边的6位为操作码（OpCode），代表load指令；中间4为代表寄存器R0；后面22位代表读取的地址。即将操作码、寄存器的编号、要读取的地址合并到了一个 32 位的指令中。接口下来再看加法运算的 add 指令（16 进制 0x08048000），二进制为：

![image-20201108152136834](https://gitee.com/itzlg/mypictures/raw/master/img/image-20201108152136834.png)

最左边6位代表add指令，接下来4位代表寄存器R0，后4位代表寄存器R1，再后4位代表寄存器R2，最后的14位没有被使用。

构造指令的过程，叫作指令的编码，通常由编译器完成；解析指令的过程，叫作指令的解码，由 CPU 完成。由此可见 CPU 内部有一个循环：

1. 首先 CPU 通过 PC 指针读取对应内存地址的指令，我们将这个步骤叫作 **Fetch**，就是获取的意思。
2. CPU 对指令进行解码，我们将这个部分叫作 **Decode**。
3. CPU 执行指令，我们将这个部分叫作 **Execution**。
4. CPU 将结果存回寄存器或者将寄存器存入内存，我们将这个步骤叫作 **Store**。

这4个步骤，称为 CPU 的指令周期。CPU 的工作就是一个周期接着一个周期，周而复始。

不同类型（不同 OpCode）的指令、参数个数、每个参数的位宽，都不一样。而参数可以是以下这三种类型：寄存器、内存地址、数值（一般是整数和浮点）。无论是寄存器、内存地址还是数值，它们都是数字。

指令从功能角度来划分，大概有以下 5 类：

- I/O 类型的指令，比如处理和内存间数据交换的指令 store/load 等；再比如将一个内存地址的数据转移到另一个内存地址的 mov 指令。
- 计算类型的指令，最多只能处理两个寄存器，比如加减乘除、位运算、比较大小等。
- 跳转类型的指令，用处就是修改 PC 指针。比如编程中大家经常会遇到需要条件判断+跳转的逻辑，比如 if-else，swtich-case、函数调用等。
- 信号类型的指令，比如发送中断的指令 trap。
- 闲置 CPU 的指令 nop，一般 CPU 都有这样一条指令，执行后 CPU 会空转一个周期。

指令从寻址模式来划分，比如同样是求和指令，可能会有 2 个版本：

- 将两个寄存器的值相加的 add 指令。
- 将一个寄存器和一个整数相加的 addi 指令。

加载内存中的数据到寄存器的 load 指令也有不同的寻址模式：

- 直接寻址：直接加载一个内存地址中的数据到寄存器的指令`la` （加载地址）
- 寄存器寻址：直接将一个数值导入寄存器的指令`li` （加载寄存器）
- 间接寻址：将一个寄存器中的数值作为地址，然后再去加载这个地址中数据的指令`lw` （将寄存器数值当作地址去加载）

即寻址模式是从指令如何获取数据的角度，对指令的一种分类。

指令的执行速度：CPU是通过石英晶体的脉冲转化成时钟信号驱动的，每次高低电平的转换就是一个周期。我们称为**时钟周期**。CPU 的主频，说的就是时钟信号的频率。比如一个 1GHz 的 CPU，说的是时钟信号的频率是 1G。

64 位和 32 位比较有哪些优势？

- 如果说的是 64 位宽 CPU，那么有 2 个优势：
    - 64 位 CPU 可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显。
    - 64 位 CPU 可以寻址更大的内存空间。
- 如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的。32 位指令在 64 位机器上执行，困难不大，可以兼容。 如果是 64 位指令，在 32 位机器上执行就困难了。因为 32 位指令在 64 位机器执行的时候，需要的是一套兼容机制；但是 64 位指令在 32 位机器上执行，32 位的寄存器都存不下指令的参数。
- 操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。









